\documentclass[10pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}

\definecolor{comment_color}{rgb}{0,0.6,0}
\definecolor{identifier_color}{rgb}{0,0,0.6}
\definecolor{keyword_color}{rgb}{0.6,0.6,0}
\definecolor{number_color}{rgb}{0.6,0,0}
\definecolor{string_color}{rgb}{0.6,0,0}

\lstdefinestyle{my_style}{
  language=Python,
  % numbers=left,
  basicstyle=\scriptsize\ttfamily,
  commentstyle=\itshape\color{comment_color},
  identifierstyle=\color{identifier_color},
  keywordstyle=\color{keyword_color},
  numberstyle=\color{number_color},
  stringstyle=\color{string_color},
}

\lstset{style=my_style}

\begin{document}
\title{Implementing the wolf sheep predation model in the Geoneric modeling language}
\author{Kor de Jong}
\maketitle

\emph{This document is work in progress. Although eventually, the contents become stable, currently it is work in progress. Please comment!}

\section{Introduction}
Geoneric is an environmental modeling platform. It is software with which environmental modelers can build models using a high level modeling language. In order to explain some features of the language, we describe an example model implementing wolf sheep predation. But before that, the data model is presented which is used to structure the environmental attributes manipulated in the model.

\section{Data model}
The Geoneric data model determines how information about environmental attributes is organized by the software. A data model determines what kind of data can be represented by the software and what kind of operations can be efficiently implemented to manipulate this data. Other examples of data models are the field- and object-based data models used in GIS software to organize field and object data respectively. In order for the modeling language to be able to integrate as many kinds of environmental attributes as possible, the Geoneric data model aims to be a superset of as many existing data models used in environmental modeling as possible.

\includegraphics{data_model.pdf}

\begin{description}
    \item[Feature] A collection of one or more attributes. A feature often corresponds with one or more real-world or conceptual phenomena, like earth, study\_area, and sheep.
    \item[Attribute] An aggregate of a domain and zero or more values.
    \item[Domain] A collection of spatio-temporal object definitions. These domain objects correspond with real-world or conceptual phenomena. The domain determines when and where an attribute is defined.
    \item[Value] Values representing an attribute value per domain object.
\end{description}

As an example, consider the feature \emph{study\_area}. It contains attributes like \emph{area} and \emph{height}. The \emph{area} attribute is a constant attribute, which means that the domain is a \emph{null domain} (the area does not vary over the study area), and the associated attribute value is a single number. The study area's \emph{height} attribute value is a 2-dimensional array containing height values. In this case, the value is coupled to a domain object defining the boundary rectangle of the raster. (Todo: Add graphics illustrating examples.)

\section{Wolf sheep predation model}
In this model wolves and sheep roam the study area for food. Sheep eat grass, and wolves eat sheep. At the start of the model we have to read the initial state of the attributes involved:

\begin{lstlisting}
area = read("area.hdf")  # Contains grass and countdown attributes.
sheep = read("sheep.hdf")  # Contains energy attribute.
wolves = read("wolves.hdf")  # Contains energy attribute.

# Wolves select sheep from area within this radius.
search_radius = 500

# Sheep and wolves gain energy from eating.
sheep_gain_from_food = 15
wolf_gain_from_food = 50

grass_regrowth_time = 14
\end{lstlisting}

The \emph{area} feature has \emph{grass} and \emph{countdown} attributes. The \emph{area.grass} attribute has a domain with polygon objects. Each of these objects is associated with a 2-dimensional value containing boolean values. A cell in the study area either contains grass or not. The \emph{area.countdown} attribute has a domain without spatio-temporal objects. The constant value is representative for the whole spatio-temporal domain.

The \emph{sheep} and \emph{wolves} features both have an \emph{energy} attribute. The \emph{sheep.energy} and \emph{wolves.energy} attributes have a domain with point objects. Each of these objects is associated with a value representing the energy level of an individual. An alternative way to model wolves and sheep is to create an \emph{animal} feature with \emph{kind} and \emph{energy} attributes, where the \emph{animal.kind} attribute would then store information about the kind of the animal. This would prevent one kind of animal to have an additional attribute, though.

Besides the three features (\emph{area}, \emph{sheep} and \emph{wolves}), the snippet defines four global attributes (\emph{search\_radius}, \emph{sheep\_gain\_from\_food}, \emph{wolf\_gain\_from\_food}, \emph{grass\_regrowth\_time}). Although these attributes are not attached to a feature, we can think of these global attributes as being part of an anonymous \emph{model} feature.

% # - countdown is a value representing time until the grass is gone.

The Geoneric modeling language allows the modeler to create functions that perform a well defined task. A sequence of such function calls is easier to understand than a sequence of the underlying, lower level operations:

\begin{lstlisting}
migrate(sheep)
eat_grass(sheep, area, sheep_gain_from_food)
sheep = die(sheep)
reproduce(sheep)

migrate(wolves)
eat_sheep(wolves, sheep, search_radius, wolf_gain_from_food)
wolves = die(wolves)
reproduce(wolves)

grow_grass(area, grass_regrowth_time)
\end{lstlisting}

This section of the model shows the individual steps that are performed during each iteration through time. For both wolves and sheep the steps involve migrating, eating, dying and reproducing. After that the grass attribute is updated.

The high-level functions that implement the model are all short aggregates of lower level operations:

\begin{lstlisting}
def migrate(
        animals):
    move(animals, ...)
    animals.energy -= 1
\end{lstlisting}

In this function, animals are moved and their energy levels updated. \emph{move} is a built-in operation that updates the spatial coordinates of the domain objects of the attribute passed in. All animals migrate in the same manner, which is not realistic, of course.

\begin{lstlisting}
def die(
        animals):
    """
    Return a subset of the feature pointed to by *animals*, containing
    those animals that have a high enough energy level to keep on
    living. The instance referred to by the *animals* identifier passed
    in is not changed.
    """
    animals = animals[energy > 0]
    return animals
\end{lstlisting}

The selection operator ([]) is used to select a subset of the feature, based on a predicate involving attribute values. The result of this selection is a new feature. For those attributes of the original feature that weren't involved in the selection, the new feature contains a \emph{reference to the attributes}. For those attributes of the original feature that were involved in the selection, the new feature contains a \emph{subset with references to the individual domain objects} in the original feature that were selected.

The local \emph{animals} identifier is overwritten to refer to the subset. We could have used any name, or we could have used no name at all, returning the result of the selection operation directly.

\begin{lstlisting}
def reproduce(
        animals):
    """
    Update the instance pointed to by *animals* to contain additional
    animals.
    """
    reproducing_animals = select_random(animals, ...)
    reproducing_animals.energy /= 2
    offspring = duplicate(reproducing_animals)
    move(offspring, ...)
\end{lstlisting}

A random selection of objects is taken, which is duplicated. The original energy level of each parent is divided between the parent and the offspring.  Duplicating (a subset of) objects, also copies the attribute values.

\begin{lstlisting}
def eat_grass(
        sheep,
        area,
        gain_from_food):
    """
    Those *sheep* objects that are standing on *area.grass*, eat some, and
    gain *gain_from_food* amount of energy.
    """
    sheep_on_grass = sheep[area.grass]
    sheep_on_grass.energy += gain_from_food
    area[sheep_on_grass].grass = False
\end{lstlisting}

The selection operator is used to select a subset of sheep, based on an external boolean attribute. A new feature is created that contains all attributes of the original feature. For each attribute, a selection is made of those domain objects that overlap with the \emph{area.grass} attribute's domain for which the attribute's value evaluates to True. \emph{area.grass} has a 2-dimensional attribute value, and only those sheep are selected that are located in cells containing a True value. False is assigned to those locations in the \emph{area.grass} attribute that correspond with the locations of sheep objects.

\begin{lstlisting}
def eat_sheep(
        wolves,
        sheep,
        search_radius,
        gain_from_food):
    """
    A random selection of *wolves* eat *sheep* that are within the
    *search_radius*, and gain *gain_from_food* amount of energy.
    """
    wolves_near_sheep = select_by_radius(wolves, sheep, search_radius)
    wolves_catching_sheep = select_random(wolves_near_sheep, ...)
    caught_sheep = select_by_radius(sheep, wolves_catching_sheep,
        search_radius, 1)
    delete(caught_sheep)
    wolves_catching_sheep.energy += gain_from_food
\end{lstlisting}

Wolves are selected by using a search radius around each wolf. A random selection of these wolves eat one of the nearby sheep.

\begin{lstlisting}
def grow_grass(
        area,
        grass_regrowth_time):
    """
    Grow grass within *area* using a *grass_regrowth_time*.
    """
    if not area.grass:
        if area.countdown <= 0:
            area.grass = True
            area.countdown = grass_regrowth_time
        else:
            area.countdown -= 1
\end{lstlisting}

% \lstinputlisting{@CMAKE_CURRENT_SOURCE_DIR@/../data_model/wolves_and_sheep.ran}

\section{Discussion}
From the example model ...

User defined functions. Domain specific, high level functions. Role of functions and components/modules.

Implicit iteration. In other document.

Data model. In other document.

Identifiers are references to data. References can be shared. Life cycle.

Relation with Python. Syntax. Scope.

\end{document}
