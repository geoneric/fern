\documentclass[10pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}

\definecolor{comment_color}{rgb}{0,0.6,0}
\definecolor{identifier_color}{rgb}{0,0,0.6}
\definecolor{keyword_color}{rgb}{0.6,0.6,0}
\definecolor{number_color}{rgb}{0.6,0,0}
\definecolor{string_color}{rgb}{0.6,0,0}

\lstdefinestyle{my_style}{
  language=Python,
  % numbers=left,
  basicstyle=\scriptsize\ttfamily,
  commentstyle=\itshape\color{comment_color},
  identifierstyle=\color{identifier_color},
  keywordstyle=\color{keyword_color},
  numberstyle=\color{number_color},
  stringstyle=\color{string_color},
}

\lstset{style=my_style}

\begin{document}
\title{Implementing the wolf sheep predation model in the Geoneric modeling language}
\author{Kor de Jong}
\maketitle

\emph{This document is work in progress. Let me know what you think!}

\section{Introduction}
Geoneric is an environmental modeling platform. It is software with which environmental modelers can build models using a high level modeling language. In order to explain some features of the language, we describe an example model implementing wolf sheep predation. But before that, the data model is presented which is used to structure the environmental attributes manipulated in the model.

\section{Data model}
The Geoneric data model determines how information about environmental attributes is organized by the software. A data model determines what kind of data can be represented by the software and what kind of operations can be efficiently implemented to manipulate this data. Other examples of data models are the field- and object-based data models used in GIS software to organize field and object data, respectively. In order for the modeling language to be able to integrate as many kinds of environmental attributes as possible, the Geoneric data model aims to be a superset of as many existing data models used in environmental modeling as possible.

\includegraphics{data_model.pdf}

\begin{description}
    \item[Feature] A collection of one or more attributes. A feature often corresponds with one or more real-world or conceptual phenomena, like earth, study\_area, and sheep.
    \item[Attribute] An aggregate of a domain and a value associated with the domain objects defined by the domain.
    \item[Domain] A collection of spatio-temporal object definitions. These domain objects correspond with real-world or conceptual phenomena. The domain determines when and where an attribute is defined.
    \item[Value] Values representing an attribute value per domain object.
\end{description}

As an example, consider the feature \emph{study\_area}, which has two attributes, called \emph{area} and \emph{height}. The \emph{area} attribute is a constant attribute, which means that the domain is a \emph{null domain} (the area does not vary over the study area), and the associated attribute value is a single number. The study area's \emph{height} attribute value is a 2-dimensional array containing height values. In this case, the value is coupled to a domain object defining the boundary rectangle of the raster. (Todo: Add graphics illustrating examples.)

The information that is needed to locate attribute values in space and time is stored in the attribute's domain. The values themselves are stored in the attribute's value.

There can be confusion about the difference between a feature and an attribute. A feature is a container for attributes. Each of these attributes has a, possibly shared, domain. This results in the possibility for a feature to contain attributes that are different in the amount of spatial and temporal variation. For example, a singe feature can have constant, spatial and temporal attributes.

Sharing of domains between attributes is important because the definitions of the domain objects potentially take up a lot of memory.

\section{Wolf sheep predation model}
In this model wolves and sheep roam the study area for food. Sheep eat grass, and wolves eat sheep. At the start of the model we have to read the initial state of the attributes involved:

\begin{lstlisting}
area = read("area.hdf")  # Contains grass and countdown attributes.
sheep = read("sheep.hdf")  # Contains energy attribute.
wolves = read("wolves.hdf")  # Contains energy attribute.

# Wolves select sheep from area within this radius.
search_radius = 500

# Sheep and wolves gain energy from eating.
sheep_gain_from_food = 15
wolf_gain_from_food = 50

grass_regrowth_time = 14
\end{lstlisting}

The \emph{area} feature has \emph{grass} and \emph{countdown} attributes. The \emph{area.grass} attribute has a domain with polygon objects. Each of these objects is associated with a 2-dimensional value containing boolean values. A cell in the study area either contains grass or not. The \emph{area.countdown} attribute has a domain without spatio-temporal objects. The constant value is representative for the whole spatio-temporal domain.

The \emph{sheep} and \emph{wolves} features both have an \emph{energy} attribute. The \emph{sheep.energy} and \emph{wolves.energy} attributes have a domain with point objects. Each of these objects is associated with a value representing the energy level of an individual. An alternative way to model wolves and sheep is to create an \emph{animal} feature with \emph{kind} and \emph{energy} attributes, where the \emph{animal.kind} attribute would then store information about the kind of the animal. This would prevent the possibility of one kind of animal to have an additional attribute, though, and it would be impossible to store an attribute value per kind of animal, like the average weight.

Besides the three features (\emph{area}, \emph{sheep} and \emph{wolves}), the snippet defines four global attributes (\emph{search\_radius}, \emph{sheep\_gain\_from\_food}, \emph{wolf\_gain\_from\_food}, \emph{grass\_regrowth\_time}). Although these attributes are not attached to a feature, we can think of these global attributes as being part of an anonymous \emph{model} feature. All attributes are part of a feature.

% # - countdown is a value representing time until the grass is gone.

The Geoneric modeling language allows the modeler to create functions that perform a well defined task. A sequence of such function calls is easier to understand than a sequence of the underlying, lower level operations. The idea is that the modeler creates higher level function by combining lower level generic building blocks. These higher level functions make more sense to people in a certain domain, than the corresponding sequence of lower level functions would.

\begin{lstlisting}
migrate(sheep)
eat_grass(sheep, area, sheep_gain_from_food)
sheep = die(sheep)
reproduce(sheep)

migrate(wolves)
eat_sheep(wolves, sheep, search_radius, wolf_gain_from_food)
wolves = die(wolves)
reproduce(wolves)

grow_grass(area, grass_regrowth_time)
\end{lstlisting}

This section of the model shows the individual steps that are performed during each iteration through time. For both wolves and sheep the steps involve migrating, eating, dying and reproducing. After that the grass attribute is updated.

The high-level functions that implement the model are all short aggregates of lower level operations:

\begin{lstlisting}
def migrate(
        animals):
    move(animals, ...)
    animals.energy -= 1
\end{lstlisting}

In this function, animals are moved and their energy levels updated. \emph{move} is a built-in operation that updates the spatial coordinates of the domain objects of the spatial attributes of the feature passed in. All animals migrate in the same manner, which is not realistic, of course.

The feature referred to by \emph{animals} is updated.

\begin{lstlisting}
def die(
        animals):
    """
    Return a subset of the feature pointed to by *animals*, containing
    those animals that have a high enough energy level to keep on
    living. The instance referred to by the *animals* identifier passed
    in is not changed.
    """
    animals = animals[energy > 0]
    return animals
\end{lstlisting}

The selection operator ([]) is used to select a subset of the feature, based on a predicate involving attribute values. The result of this selection is a new feature. For those attributes of the original feature that weren't involved in the selection, the new feature contains a \emph{reference to the original attributes}. For those attributes of the original feature that were involved in the selection, the new feature contains a \emph{subset with references to the individual domain objects in the original feature} that were selected.

The local \emph{animals} identifier is overwritten to refer to the subset. We could have used any name, or we could have used no name at all, returning the result of the selection operation directly. The feature originally referred to by \emph{animals} is not changed.

\begin{lstlisting}
def reproduce(
        animals):
    """
    Update the instance pointed to by *animals* to contain additional
    animals.
    """
    energy_per_selected_animal = select_random(animals.energy, ...)
    energy_per_selected_animal /= 2
    offspring = duplicate(energy_per_selected_animals)
    move(offspring, ...)
\end{lstlisting}

A random selection of objects is taken, which is duplicated. The original energy level of each parent is divided between the parent and the offspring. Duplicating (a subset of) objects, also copies the attribute values.

Note that the \emph{animals} feature passed in is a container of animal attributes. One of these attributes is the \emph{energy} attribute that contains an energy value per point object representing an animal. To select points representing an animal, a selection of the \emph{animal.energy} attribute needs to be made. This results in a subset of the domain objects (the points) associated with the \emph{energy} attribute. An alternative would be to add a \emph{location} attribute linked to a point domain representing the animals, and without an attribute value. The \emph{energy} attribute would then share this domain with the \emph{location} attribute.

\begin{lstlisting}
def eat_grass(
        sheep,
        area,
        gain_from_food):
    """
    Those *sheep* objects that are standing on *area.grass*, eat some, and
    gain *gain_from_food* amount of energy.
    """
    sheep_on_grass = sheep[area.grass]
    sheep_on_grass.energy += gain_from_food
    area[sheep_on_grass].grass = False
\end{lstlisting}

The selection operator is used to select a subset of sheep, based on an external boolean attribute. A new feature is created that contains all attributes of the original feature. For each attribute, a selection is made of those domain objects that overlap with the \emph{area.grass} attribute's domain for which the attribute's value evaluates to True. \emph{area.grass} has a 2-dimensional attribute value, and only those sheep are selected that are located in cells containing a True value. False is assigned to those locations in the \emph{area.grass} attribute that correspond with the locations of sheep objects.

\begin{lstlisting}
def eat_sheep(
        wolves,
        sheep,
        search_radius,
        gain_from_food):
    """
    A random selection of *wolves* eat *sheep* that are within the
    *search_radius*, and gain *gain_from_food* amount of energy.
    """
    wolves_near_sheep = select_by_radius(wolves, sheep, search_radius)
    wolves_catching_sheep = select_random(wolves_near_sheep, ...)
    nr_sheep_eaten_per_wolf = 1
    caught_sheep = select_by_radius(sheep, wolves_catching_sheep,
        search_radius, nr_sheep_eaten_per_wolf)
    delete(caught_sheep)
    wolves_catching_sheep.energy += gain_from_food
\end{lstlisting}

Wolves are selected by using a search radius around each wolf. A random selection of these wolves eat one of the nearby sheep.

\begin{lstlisting}
def grow_grass(
        area,
        grass_regrowth_time):
    """
    Grow grass within *area* using a *grass_regrowth_time*.
    """
    if not area.grass:
        if area.countdown <= 0:
            area.grass = True
            area.countdown = grass_regrowth_time
        else:
            area.countdown -= 1
\end{lstlisting}

% \lstinputlisting{@CMAKE_CURRENT_SOURCE_DIR@/../data_model/wolves_and_sheep.ran}

\section{Conclusions}

When looking at the implementation of the wolf sheep predation model, some observations can be made about the modeling language:

\begin{itemize}
    \item Identifiers are references to features and attributes. References can be shared.
    \item Feature attributes are accessed using the attribute selection operator (.).
    \item Attribute selections are made using the selection operator ([]).
    \item The language allows the user to define functions. (It will also be possible to import modules.)
    \item There is no information in a model about iteration through time. This is handled by the interpreter, based on a set of rules. This will be presented in another document.
\end{itemize}

The syntax of the modeling language, is a subset of the Python programming language. There is no other relation between the platform and Python.

In this document, the focus was put on the language, not on the data model. There is much to say about the data model and this will be presented in another document.
\end{document}
